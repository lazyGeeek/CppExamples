#pragma once

#include <cassert>
#include <atomic>
#include <iostream>
#include <thread>
#include <vector>

namespace Threads
{
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Basic Atomic ////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    void Increment(std::atomic<int>& counter)
    {
        for (int i = 0; i < 1000; i++)
        {
            counter++;
        }
    }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Atomic Flag /////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    void Acquire(std::atomic_flag& lock, int id)
    {
        for (int i = 0; i < 5; ++i)
        {
            while (lock.test_and_set(std::memory_order_acquire)) { }

            // Acquire lock
            std::cout << "Thread " << id << " is running." << std::endl;
            lock.clear(std::memory_order_release); // Release lock
        }
    }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Memory Order Relaxed ////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    void MemoryOrderRelaxed(std::atomic<int>& counter)
    {
        for (int n = 0; n < 1000; ++n)
            counter.fetch_add(1, std::memory_order_relaxed);
    }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Memory Order Release/Acquire ////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    void ReleaseAcquireOrderingProducer(std::atomic<std::string*>& str, int& data)
    {
        std::string* p = new std::string("Hello");
        data = 42;
        str.store(p, std::memory_order_release);
    }

    void ReleaseAcquireOrderingConsumer(std::atomic<std::string*>& str, int& data)
    {
        std::string* p2 = nullptr;
        while (!(p2 = str.load(std::memory_order_acquire)));
        // while (!(p2 = str.load(std::memory_order_consume))); // same result
        
        assert(*p2 == "Hello"); // never fires
        assert(data == 42); // never fires
    }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Sequentially-consistent ordering ////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
    void SequentiallyConsistentOrderingX(std::atomic<int>& x)
    {
        x.store(1, std::memory_order_seq_cst);
    }
    
    void SequentiallyConsistentOrderingY(std::atomic<int>& y)
    {
        y.store(1, std::memory_order_seq_cst);
    }
    
    void SequentiallyConsistentOrderingReadXThenY(std::atomic<int>& x, std::atomic<int>& y, std::atomic<int>& z)
    {
        while (!x.load(std::memory_order_seq_cst));

        if (y.load(std::memory_order_seq_cst))
            ++z;
    }
    
    void SequentiallyConsistentOrderingReadYThenX(std::atomic<int>& x, std::atomic<int>& y, std::atomic<int>& z)
    {
        while (!y.load(std::memory_order_seq_cst));

        if (x.load(std::memory_order_seq_cst))
            ++z;
    }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Custom Atomic Data //////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    template <typename T>
    struct Node
    {
        std::atomic<Node*> next;
        std::atomic<Node*> prev;
        T data;

        // ...
    };

    template <typename T>  
    class AtomicList
    {
    public:
        void push(T value)
        {
            Node<T>* newNode = new Node<T>(value); 
            Node<T>* prevHead = head.load();

            while(!head.compare_exchange_weak(prevHead, newNode))
            {
            // retry  
            }

            newNode->next = prevHead;  
            prevHead->prev = newNode; 
        }

    // ...

    private:
        std::atomic<Node<T>*> head;
    };

    void TestAtomic()
    {
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Basic Atomic ////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::atomic<int> counter(0);

        std::thread t1(Increment, std::ref(counter));
        std::thread t2(Increment, std::ref(counter));

        t1.join();
        t2.join();

        std::cout << "[Atomic] Counter is " << counter << "\n";

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Atomic Flag /////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        std::atomic_flag lock = ATOMIC_FLAG_INIT;

        std::thread t3(Acquire, std::ref(lock), 1);
        std::thread t4(Acquire, std::ref(lock), 2);

        t3.join();
        t4.join();

        std::cout << "[Atomic Flag] Finished\n";

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Memory Order Relaxed ////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        counter.store(0);

        std::vector<std::thread> threads;
        for (int n = 0; n < 10; ++n)
            threads.emplace_back(MemoryOrderRelaxed, std::ref(counter));
        
        for (auto& thread : threads)
            thread.join();

        std::cout << "[Memory Order Relaxed] Counter is " << counter << '\n';

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Memory Order Release/Acquire/Consume ////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        std::atomic<std::string*> str(nullptr);
        int data = 0;

        std::thread t5(ReleaseAcquireOrderingProducer, std::ref(str), std::ref(data));
        std::thread t6(ReleaseAcquireOrderingConsumer, std::ref(str), std::ref(data));
        t5.join();
        t6.join();

        std::cout << "[Memory Order Release/Acquire/Consume] String is \"" << *str << "\" Data is " << data << '\n';

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Sequentially-consistent ordering ////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        std::atomic<int> x = { 0 };
        std::atomic<int> y = { 0 };
        std::atomic<int> z = { 0 };

        std::thread t7(SequentiallyConsistentOrderingX, std::ref(x));
        std::thread t8(SequentiallyConsistentOrderingY, std::ref(y));
        std::thread t9(SequentiallyConsistentOrderingReadXThenY, std::ref(x), std::ref(y), std::ref(z));
        std::thread t10(SequentiallyConsistentOrderingReadYThenX, std::ref(x), std::ref(y), std::ref(z));
        
        t7.join();
        t8.join();
        t9.join();
        t10.join();

        assert(z.load() != 0); // will never happen

        std::cout << "[Sequentially-consistent ordering] Final Value is " << z << '\n';
    }
}
